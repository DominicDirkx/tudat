\hypertarget{classtudat_1_1propagators_1_1NBodyStateDerivative}{}\section{tudat\+:\+:propagators\+:\+:N\+Body\+State\+Derivative$<$ State\+Scalar\+Type, Time\+Type $>$ Class Template Reference}
\label{classtudat_1_1propagators_1_1NBodyStateDerivative}\index{tudat\+::propagators\+::\+N\+Body\+State\+Derivative$<$ State\+Scalar\+Type, Time\+Type $>$@{tudat\+::propagators\+::\+N\+Body\+State\+Derivative$<$ State\+Scalar\+Type, Time\+Type $>$}}


State derivative for the translational dynamics of N bodies.  




{\ttfamily \#include $<$n\+Body\+State\+Derivative.\+h$>$}



Inheritance diagram for tudat\+:\+:propagators\+:\+:N\+Body\+State\+Derivative$<$ State\+Scalar\+Type, Time\+Type $>$\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classtudat_1_1propagators_1_1NBodyStateDerivative__inherit__graph}
\end{center}
\end{figure}


Collaboration diagram for tudat\+:\+:propagators\+:\+:N\+Body\+State\+Derivative$<$ State\+Scalar\+Type, Time\+Type $>$\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classtudat_1_1propagators_1_1NBodyStateDerivative__coll__graph}
\end{center}
\end{figure}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classtudat_1_1propagators_1_1NBodyStateDerivative_a9436969bd31800277db367e8fefb1f38}{N\+Body\+State\+Derivative} (const basic\+\_\+astrodynamics\+::\+Acceleration\+Map \&acceleration\+Models\+Per\+Body, const boost\+::shared\+\_\+ptr$<$ \hyperlink{classtudat_1_1propagators_1_1CentralBodyData}{Central\+Body\+Data}$<$ State\+Scalar\+Type, Time\+Type $>$ $>$ central\+Body\+Data, const Translational\+Propagator\+Type propagator\+Type, const std\+::vector$<$ std\+::string $>$ \&bodies\+To\+Integrate)
\item 
virtual \hyperlink{classtudat_1_1propagators_1_1NBodyStateDerivative_a350b843b4f15844b59b0187e00022313}{$\sim$\+N\+Body\+State\+Derivative} ()\hypertarget{classtudat_1_1propagators_1_1NBodyStateDerivative_a350b843b4f15844b59b0187e00022313}{}\label{classtudat_1_1propagators_1_1NBodyStateDerivative_a350b843b4f15844b59b0187e00022313}

\begin{DoxyCompactList}\small\item\em Destructor. \end{DoxyCompactList}\item 
virtual void \hyperlink{classtudat_1_1propagators_1_1NBodyStateDerivative_aa1485260a3a591741454070ce4b89fb2}{clear\+Derived\+Translational\+State\+Derivative\+Model} ()
\begin{DoxyCompactList}\small\item\em Function to clear any reference/cached values of state derivative model. \end{DoxyCompactList}\item 
void \hyperlink{classtudat_1_1propagators_1_1NBodyStateDerivative_a24ded178bab0fdf4155b5c2fea461e9a}{clear\+Translational\+State\+Derivative\+Model} ()
\begin{DoxyCompactList}\small\item\em Function to clear reference/cached values of acceleration models. \end{DoxyCompactList}\item 
void \hyperlink{classtudat_1_1propagators_1_1NBodyStateDerivative_a1a4df6d3bc026a5d7d780f812fc10ba3}{clear\+State\+Derivative\+Model} ()
\begin{DoxyCompactList}\small\item\em Function to clear reference/cached values of translational state derivative model. \end{DoxyCompactList}\item 
void \hyperlink{classtudat_1_1propagators_1_1NBodyStateDerivative_a1db2b5b538eeb857e040a8744d886e61}{update\+State\+Derivative\+Model} (const Time\+Type current\+Time)
\begin{DoxyCompactList}\small\item\em Function to update the state derivative model to the current time. \end{DoxyCompactList}\item 
void \hyperlink{classtudat_1_1propagators_1_1NBodyStateDerivative_a17b2f9c92c77ced3cfa2b563878c84eb}{convert\+Current\+State\+To\+Global\+Representation} (const Eigen\+::\+Matrix$<$ State\+Scalar\+Type, Eigen\+::\+Dynamic, 1 $>$ \&internal\+Solution, const Time\+Type \&time, Eigen\+::\+Block$<$ Eigen\+::\+Matrix$<$ State\+Scalar\+Type, Eigen\+::\+Dynamic, 1 $>$ $>$ current\+Cartesian\+Local\+Soluton)
\begin{DoxyCompactList}\small\item\em Function to convert the propagator-\/specific form of the state to the conventional form in the global frame. \end{DoxyCompactList}\item 
std\+::vector$<$ std\+::string $>$ \hyperlink{classtudat_1_1propagators_1_1NBodyStateDerivative_a6371faac2a8c345ff0b585708e5df1f8}{get\+Bodies\+To\+Be\+Integrated\+Numerically} ()
\begin{DoxyCompactList}\small\item\em Function to get list of names of bodies that are to be integrated numerically. \end{DoxyCompactList}\item 
virtual basic\+\_\+astrodynamics\+::\+Acceleration\+Map \hyperlink{classtudat_1_1propagators_1_1NBodyStateDerivative_ace7b03eeaa9a2571af87d578d3b747c7}{get\+Full\+Accelerations\+Map} ()
\begin{DoxyCompactList}\small\item\em Function to get map containing the list of accelerations acting on each body,. \end{DoxyCompactList}\item 
boost\+::shared\+\_\+ptr$<$ \hyperlink{classtudat_1_1propagators_1_1CentralBodyData}{Central\+Body\+Data}$<$ State\+Scalar\+Type, Time\+Type $>$ $>$ \hyperlink{classtudat_1_1propagators_1_1NBodyStateDerivative_a3f9dbc0f8bff359e387bdc8a488e1495}{get\+Central\+Body\+Data} ()
\begin{DoxyCompactList}\small\item\em Function to get object providing the current integration origins. \end{DoxyCompactList}\item 
Translational\+Propagator\+Type \hyperlink{classtudat_1_1propagators_1_1NBodyStateDerivative_a6854e29873694a2ec2f25950b5315796}{get\+Propagator\+Type} ()
\begin{DoxyCompactList}\small\item\em Function to get type of propagator that is to be used (i.\+e. Cowell, Encke, etc.) \end{DoxyCompactList}\item 
int \hyperlink{classtudat_1_1propagators_1_1NBodyStateDerivative_a93aeb6b8f4de1817816ad19ddec65a19}{get\+State\+Size} ()
\begin{DoxyCompactList}\small\item\em Function to return the size of the state handled by the object. \end{DoxyCompactList}\item 
Eigen\+::\+Vector3d \hyperlink{classtudat_1_1propagators_1_1NBodyStateDerivative_a2f6fa526b5bfa1e80a7c4a80fa36ea91}{get\+Total\+Acceleration\+For\+Body} (const std\+::string \&body\+Name)
\begin{DoxyCompactList}\small\item\em Function to retrieve the total acceleration acting on a given body. \end{DoxyCompactList}\item 
basic\+\_\+astrodynamics\+::\+Acceleration\+Map \hyperlink{classtudat_1_1propagators_1_1NBodyStateDerivative_a3c8a3939cf0e2a6b2ea1c23e44196ac7}{get\+Accelerations\+Map} ()
\begin{DoxyCompactList}\small\item\em Function to retrieve the map containing the list of accelerations acting on each body. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Protected Member Functions}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{classtudat_1_1propagators_1_1NBodyStateDerivative_a107c7354c39b9793ddee9eb6b363a4da}{create\+Acceleration\+Model\+List} ()
\item 
void \hyperlink{classtudat_1_1propagators_1_1NBodyStateDerivative_a9dc88981ebb90ecf8f7673760d321597}{sum\+State\+Derivative\+Contributions} (const Eigen\+::\+Matrix$<$ State\+Scalar\+Type, Eigen\+::\+Dynamic, 1 $>$ \&state\+Of\+System\+To\+Be\+Integrated, Eigen\+::\+Block$<$ Eigen\+::\+Matrix$<$ State\+Scalar\+Type, Eigen\+::\+Dynamic, Eigen\+::\+Dynamic $>$ $>$ state\+Derivative)
\begin{DoxyCompactList}\small\item\em Function to get the state derivative of the system in Cartesian coordinates. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Protected Attributes}
\begin{DoxyCompactItemize}
\item 
basic\+\_\+astrodynamics\+::\+Acceleration\+Map \hyperlink{classtudat_1_1propagators_1_1NBodyStateDerivative_aa9ae6d8dfda131ffca5b23c1564342af}{acceleration\+Models\+Per\+Body\+\_\+}
\begin{DoxyCompactList}\small\item\em A map containing the list of accelerations acting on each body,. \end{DoxyCompactList}\item 
std\+::vector$<$ boost\+::shared\+\_\+ptr$<$ \hyperlink{classtudat_1_1basic__astrodynamics_1_1AccelerationModel}{basic\+\_\+astrodynamics\+::\+Acceleration\+Model}$<$ Eigen\+::\+Vector3d $>$ $>$ $>$ \hyperlink{classtudat_1_1propagators_1_1NBodyStateDerivative_a0c1448d2a35b826e8e97a21e8cf32d12}{acceleration\+Model\+List\+\_\+}\hypertarget{classtudat_1_1propagators_1_1NBodyStateDerivative_a0c1448d2a35b826e8e97a21e8cf32d12}{}\label{classtudat_1_1propagators_1_1NBodyStateDerivative_a0c1448d2a35b826e8e97a21e8cf32d12}

\begin{DoxyCompactList}\small\item\em Vector of acceleration models, containing all entries of acceleration\+Models\+Per\+Body\+\_\+. \end{DoxyCompactList}\item 
boost\+::shared\+\_\+ptr$<$ \hyperlink{classtudat_1_1propagators_1_1CentralBodyData}{Central\+Body\+Data}$<$ State\+Scalar\+Type, Time\+Type $>$ $>$ \hyperlink{classtudat_1_1propagators_1_1NBodyStateDerivative_a07725dacbad6336f213dd64f2291b70a}{central\+Body\+Data\+\_\+}\hypertarget{classtudat_1_1propagators_1_1NBodyStateDerivative_a07725dacbad6336f213dd64f2291b70a}{}\label{classtudat_1_1propagators_1_1NBodyStateDerivative_a07725dacbad6336f213dd64f2291b70a}

\begin{DoxyCompactList}\small\item\em Object responsible for providing the current integration origins from the global origins. \end{DoxyCompactList}\item 
Translational\+Propagator\+Type \hyperlink{classtudat_1_1propagators_1_1NBodyStateDerivative_a0b30df07d47b0cf367fe633fd15c5736}{propagator\+Type\+\_\+}\hypertarget{classtudat_1_1propagators_1_1NBodyStateDerivative_a0b30df07d47b0cf367fe633fd15c5736}{}\label{classtudat_1_1propagators_1_1NBodyStateDerivative_a0b30df07d47b0cf367fe633fd15c5736}

\begin{DoxyCompactList}\small\item\em Type of propagator that is to be used (i.\+e. Cowell, Encke, etc.) \end{DoxyCompactList}\item 
std\+::vector$<$ std\+::string $>$ \hyperlink{classtudat_1_1propagators_1_1NBodyStateDerivative_a87be0b1f42e3315d24947a9434c84db7}{bodies\+To\+Be\+Integrated\+Numerically\+\_\+}\hypertarget{classtudat_1_1propagators_1_1NBodyStateDerivative_a87be0b1f42e3315d24947a9434c84db7}{}\label{classtudat_1_1propagators_1_1NBodyStateDerivative_a87be0b1f42e3315d24947a9434c84db7}

\begin{DoxyCompactList}\small\item\em List of names of bodies that are to be integrated numerically. \end{DoxyCompactList}\item 
std\+::vector$<$ int $>$ {\bfseries body\+Order\+\_\+}\hypertarget{classtudat_1_1propagators_1_1NBodyStateDerivative_a04d54fb3449d2859a301feb7efc8aa8f}{}\label{classtudat_1_1propagators_1_1NBodyStateDerivative_a04d54fb3449d2859a301feb7efc8aa8f}

\item 
std\+::unordered\+\_\+map$<$ std\+::string, std\+::vector$<$ boost\+::shared\+\_\+ptr$<$ \hyperlink{classtudat_1_1basic__astrodynamics_1_1AccelerationModel}{basic\+\_\+astrodynamics\+::\+Acceleration\+Model}$<$ Eigen\+::\+Vector3d $>$ $>$ $>$ $>$\+::iterator \hyperlink{classtudat_1_1propagators_1_1NBodyStateDerivative_a153ea76f2a8254565b44de4126ae583f}{inner\+Acceleration\+Iterator}\hypertarget{classtudat_1_1propagators_1_1NBodyStateDerivative_a153ea76f2a8254565b44de4126ae583f}{}\label{classtudat_1_1propagators_1_1NBodyStateDerivative_a153ea76f2a8254565b44de4126ae583f}

\begin{DoxyCompactList}\small\item\em Predefined iterator to save (de-\/)allocation time. \end{DoxyCompactList}\item 
std\+::unordered\+\_\+map$<$ std\+::string, std\+::unordered\+\_\+map$<$ std\+::string, std\+::vector$<$ boost\+::shared\+\_\+ptr$<$ \hyperlink{classtudat_1_1basic__astrodynamics_1_1AccelerationModel}{basic\+\_\+astrodynamics\+::\+Acceleration\+Model}$<$ Eigen\+::\+Vector3d $>$ $>$ $>$ $>$ $>$\+::iterator \hyperlink{classtudat_1_1propagators_1_1NBodyStateDerivative_acaa5a4b14235f22e56c61eb569d09695}{outer\+Acceleration\+Iterator}\hypertarget{classtudat_1_1propagators_1_1NBodyStateDerivative_acaa5a4b14235f22e56c61eb569d09695}{}\label{classtudat_1_1propagators_1_1NBodyStateDerivative_acaa5a4b14235f22e56c61eb569d09695}

\begin{DoxyCompactList}\small\item\em Predefined iterator to save (de-\/)allocation time. \end{DoxyCompactList}\item 
std\+::vector$<$ Eigen\+::\+Matrix$<$ State\+Scalar\+Type, 6, 1 $>$ $>$ \hyperlink{classtudat_1_1propagators_1_1NBodyStateDerivative_afc6bc65cd868409d374eb558f07770a4}{central\+Body\+Inertial\+States\+\_\+}\hypertarget{classtudat_1_1propagators_1_1NBodyStateDerivative_afc6bc65cd868409d374eb558f07770a4}{}\label{classtudat_1_1propagators_1_1NBodyStateDerivative_afc6bc65cd868409d374eb558f07770a4}

\begin{DoxyCompactList}\small\item\em List of states of teh central bodies of the propagated bodies. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
\subsubsection*{template$<$typename State\+Scalar\+Type = double, typename Time\+Type = double$>$\\*
class tudat\+::propagators\+::\+N\+Body\+State\+Derivative$<$ State\+Scalar\+Type, Time\+Type $>$}

State derivative for the translational dynamics of N bodies. 

This class calculates the trabnslational state derivative of any number of bodies, each under the influence of any number of bodies, both from the set being integrated and otherwise. 

\subsection{Constructor \& Destructor Documentation}
\index{tudat\+::propagators\+::\+N\+Body\+State\+Derivative@{tudat\+::propagators\+::\+N\+Body\+State\+Derivative}!N\+Body\+State\+Derivative@{N\+Body\+State\+Derivative}}
\index{N\+Body\+State\+Derivative@{N\+Body\+State\+Derivative}!tudat\+::propagators\+::\+N\+Body\+State\+Derivative@{tudat\+::propagators\+::\+N\+Body\+State\+Derivative}}
\subsubsection[{\texorpdfstring{N\+Body\+State\+Derivative(const basic\+\_\+astrodynamics\+::\+Acceleration\+Map \&acceleration\+Models\+Per\+Body, const boost\+::shared\+\_\+ptr$<$ Central\+Body\+Data$<$ State\+Scalar\+Type, Time\+Type $>$ $>$ central\+Body\+Data, const Translational\+Propagator\+Type propagator\+Type, const std\+::vector$<$ std\+::string $>$ \&bodies\+To\+Integrate)}{NBodyStateDerivative(const basic_astrodynamics::AccelerationMap &accelerationModelsPerBody, const boost::shared_ptr< CentralBodyData< StateScalarType, TimeType > > centralBodyData, const TranslationalPropagatorType propagatorType, const std::vector< std::string > &bodiesToIntegrate)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename State\+Scalar\+Type  = double, typename Time\+Type  = double$>$ {\bf tudat\+::propagators\+::\+N\+Body\+State\+Derivative}$<$ State\+Scalar\+Type, Time\+Type $>$\+::{\bf N\+Body\+State\+Derivative} (
\begin{DoxyParamCaption}
\item[{const basic\+\_\+astrodynamics\+::\+Acceleration\+Map \&}]{acceleration\+Models\+Per\+Body, }
\item[{const boost\+::shared\+\_\+ptr$<$ {\bf Central\+Body\+Data}$<$ State\+Scalar\+Type, Time\+Type $>$ $>$}]{central\+Body\+Data, }
\item[{const Translational\+Propagator\+Type}]{propagator\+Type, }
\item[{const std\+::vector$<$ std\+::string $>$ \&}]{bodies\+To\+Integrate}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{classtudat_1_1propagators_1_1NBodyStateDerivative_a9436969bd31800277db367e8fefb1f38}{}\label{classtudat_1_1propagators_1_1NBodyStateDerivative_a9436969bd31800277db367e8fefb1f38}
Constructor from data for translational Cartesian state derivative creation. It is assumed that all acceleration are exerted on bodies by bodies.

From this constructor, the object for generating the state derivative is created. Required are the acceleration models, a map of all (named) bodies involved in the simulation and a list of body names, which must be a subset of the body\+List that are to be numerically integrated. Note that the state derivative model currently has 3 degrees of freedom (3 translational) in Cartesian coordinates. 
\begin{DoxyParams}{Parameters}
{\em acceleration\+Models\+Per\+Body} & A map containing the list of accelerations acting on each body, identifying the body being acted on and the body acted on by an acceleration. The map has as key a string denoting the name of the body the list of accelerations, provided as the value corresponding to a key, is acting on. This map-\/value is again a map with string as key, denoting the body exerting the acceleration, and as value a pointer to an acceleration model. \\
\hline
{\em central\+Body\+Data} & Object responsible for providing the current integration origins from the global origins. \\
\hline
{\em propagator\+Type} & Type of propagator that is to be used (i.\+e. Cowell, Encke, etc.) \\
\hline
{\em bodies\+To\+Integrate} & List of names of bodies that are to be integrated numerically. \\
\hline
\end{DoxyParams}


\subsection{Member Function Documentation}
\index{tudat\+::propagators\+::\+N\+Body\+State\+Derivative@{tudat\+::propagators\+::\+N\+Body\+State\+Derivative}!clear\+Derived\+Translational\+State\+Derivative\+Model@{clear\+Derived\+Translational\+State\+Derivative\+Model}}
\index{clear\+Derived\+Translational\+State\+Derivative\+Model@{clear\+Derived\+Translational\+State\+Derivative\+Model}!tudat\+::propagators\+::\+N\+Body\+State\+Derivative@{tudat\+::propagators\+::\+N\+Body\+State\+Derivative}}
\subsubsection[{\texorpdfstring{clear\+Derived\+Translational\+State\+Derivative\+Model()}{clearDerivedTranslationalStateDerivativeModel()}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename State\+Scalar\+Type  = double, typename Time\+Type  = double$>$ virtual void {\bf tudat\+::propagators\+::\+N\+Body\+State\+Derivative}$<$ State\+Scalar\+Type, Time\+Type $>$\+::clear\+Derived\+Translational\+State\+Derivative\+Model (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}\hypertarget{classtudat_1_1propagators_1_1NBodyStateDerivative_aa1485260a3a591741454070ce4b89fb2}{}\label{classtudat_1_1propagators_1_1NBodyStateDerivative_aa1485260a3a591741454070ce4b89fb2}


Function to clear any reference/cached values of state derivative model. 

Function to clear any reference/cached values of state derivative model, in addition to those performed in the clear\+Translational\+State\+Derivative\+Model function. Default implementation is empty. \index{tudat\+::propagators\+::\+N\+Body\+State\+Derivative@{tudat\+::propagators\+::\+N\+Body\+State\+Derivative}!clear\+State\+Derivative\+Model@{clear\+State\+Derivative\+Model}}
\index{clear\+State\+Derivative\+Model@{clear\+State\+Derivative\+Model}!tudat\+::propagators\+::\+N\+Body\+State\+Derivative@{tudat\+::propagators\+::\+N\+Body\+State\+Derivative}}
\subsubsection[{\texorpdfstring{clear\+State\+Derivative\+Model()}{clearStateDerivativeModel()}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename State\+Scalar\+Type  = double, typename Time\+Type  = double$>$ void {\bf tudat\+::propagators\+::\+N\+Body\+State\+Derivative}$<$ State\+Scalar\+Type, Time\+Type $>$\+::clear\+State\+Derivative\+Model (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}\hypertarget{classtudat_1_1propagators_1_1NBodyStateDerivative_a1a4df6d3bc026a5d7d780f812fc10ba3}{}\label{classtudat_1_1propagators_1_1NBodyStateDerivative_a1a4df6d3bc026a5d7d780f812fc10ba3}


Function to clear reference/cached values of translational state derivative model. 

Function to clear reference/cached values of translational state derivative model. For each derived class, this entails resetting the current time in the acceleration models to NaN (see clear\+Translational\+State\+Derivative\+Model). Every derived class requiring additional values to be cleared should implement the clear\+Derived\+Translational\+State\+Derivative\+Model function. 

Implements \hyperlink{classtudat_1_1propagators_1_1SingleStateTypeDerivative_a39840fb71c86fcc5e70804dd6aa7683b}{tudat\+::propagators\+::\+Single\+State\+Type\+Derivative$<$ State\+Scalar\+Type, Time\+Type $>$}.

\index{tudat\+::propagators\+::\+N\+Body\+State\+Derivative@{tudat\+::propagators\+::\+N\+Body\+State\+Derivative}!clear\+Translational\+State\+Derivative\+Model@{clear\+Translational\+State\+Derivative\+Model}}
\index{clear\+Translational\+State\+Derivative\+Model@{clear\+Translational\+State\+Derivative\+Model}!tudat\+::propagators\+::\+N\+Body\+State\+Derivative@{tudat\+::propagators\+::\+N\+Body\+State\+Derivative}}
\subsubsection[{\texorpdfstring{clear\+Translational\+State\+Derivative\+Model()}{clearTranslationalStateDerivativeModel()}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename State\+Scalar\+Type  = double, typename Time\+Type  = double$>$ void {\bf tudat\+::propagators\+::\+N\+Body\+State\+Derivative}$<$ State\+Scalar\+Type, Time\+Type $>$\+::clear\+Translational\+State\+Derivative\+Model (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{classtudat_1_1propagators_1_1NBodyStateDerivative_a24ded178bab0fdf4155b5c2fea461e9a}{}\label{classtudat_1_1propagators_1_1NBodyStateDerivative_a24ded178bab0fdf4155b5c2fea461e9a}


Function to clear reference/cached values of acceleration models. 

Function to clear reference/cached values of acceleration models, to ensure that they are all recalculated. \index{tudat\+::propagators\+::\+N\+Body\+State\+Derivative@{tudat\+::propagators\+::\+N\+Body\+State\+Derivative}!convert\+Current\+State\+To\+Global\+Representation@{convert\+Current\+State\+To\+Global\+Representation}}
\index{convert\+Current\+State\+To\+Global\+Representation@{convert\+Current\+State\+To\+Global\+Representation}!tudat\+::propagators\+::\+N\+Body\+State\+Derivative@{tudat\+::propagators\+::\+N\+Body\+State\+Derivative}}
\subsubsection[{\texorpdfstring{convert\+Current\+State\+To\+Global\+Representation(const Eigen\+::\+Matrix$<$ State\+Scalar\+Type, Eigen\+::\+Dynamic, 1 $>$ \&internal\+Solution, const Time\+Type \&time, Eigen\+::\+Block$<$ Eigen\+::\+Matrix$<$ State\+Scalar\+Type, Eigen\+::\+Dynamic, 1 $>$ $>$ current\+Cartesian\+Local\+Soluton)}{convertCurrentStateToGlobalRepresentation(const Eigen::Matrix< StateScalarType, Eigen::Dynamic, 1 > &internalSolution, const TimeType &time, Eigen::Block< Eigen::Matrix< StateScalarType, Eigen::Dynamic, 1 > > currentCartesianLocalSoluton)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename State\+Scalar\+Type  = double, typename Time\+Type  = double$>$ void {\bf tudat\+::propagators\+::\+N\+Body\+State\+Derivative}$<$ State\+Scalar\+Type, Time\+Type $>$\+::convert\+Current\+State\+To\+Global\+Representation (
\begin{DoxyParamCaption}
\item[{const Eigen\+::\+Matrix$<$ State\+Scalar\+Type, Eigen\+::\+Dynamic, 1 $>$ \&}]{internal\+Solution, }
\item[{const Time\+Type \&}]{time, }
\item[{Eigen\+::\+Block$<$ Eigen\+::\+Matrix$<$ State\+Scalar\+Type, Eigen\+::\+Dynamic, 1 $>$ $>$}]{current\+Cartesian\+Local\+Soluton}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}\hypertarget{classtudat_1_1propagators_1_1NBodyStateDerivative_a17b2f9c92c77ced3cfa2b563878c84eb}{}\label{classtudat_1_1propagators_1_1NBodyStateDerivative_a17b2f9c92c77ced3cfa2b563878c84eb}


Function to convert the propagator-\/specific form of the state to the conventional form in the global frame. 

Function to convert the propagator-\/specific form of the state to the conventional form in the global frame. The conventional form for translational dynamics this is the Cartesian position and velocity). The inertial frame is typically the barycenter with J2000/\+E\+C\+L\+I\+P\+J2000 orientation, but may differ depending on simulation settings. 
\begin{DoxyParams}{Parameters}
{\em internal\+Solution} & State in propagator-\/specific form (i.\+e. form that is used in numerical integration). \\
\hline
{\em time} & Current time at which the state is valid. \\
\hline
{\em current\+Cartesian\+Local\+Soluton} & State (internal\+Solution), converted to the Cartesian state in inertial coordinates (returned by reference). \\
\hline
\end{DoxyParams}


Implements \hyperlink{classtudat_1_1propagators_1_1SingleStateTypeDerivative_ac1f76ef281c53cccc0ea66a12973b916}{tudat\+::propagators\+::\+Single\+State\+Type\+Derivative$<$ State\+Scalar\+Type, Time\+Type $>$}.

\index{tudat\+::propagators\+::\+N\+Body\+State\+Derivative@{tudat\+::propagators\+::\+N\+Body\+State\+Derivative}!create\+Acceleration\+Model\+List@{create\+Acceleration\+Model\+List}}
\index{create\+Acceleration\+Model\+List@{create\+Acceleration\+Model\+List}!tudat\+::propagators\+::\+N\+Body\+State\+Derivative@{tudat\+::propagators\+::\+N\+Body\+State\+Derivative}}
\subsubsection[{\texorpdfstring{create\+Acceleration\+Model\+List()}{createAccelerationModelList()}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename State\+Scalar\+Type  = double, typename Time\+Type  = double$>$ void {\bf tudat\+::propagators\+::\+N\+Body\+State\+Derivative}$<$ State\+Scalar\+Type, Time\+Type $>$\+::create\+Acceleration\+Model\+List (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [protected]}}\hypertarget{classtudat_1_1propagators_1_1NBodyStateDerivative_a107c7354c39b9793ddee9eb6b363a4da}{}\label{classtudat_1_1propagators_1_1NBodyStateDerivative_a107c7354c39b9793ddee9eb6b363a4da}
Function to set the vector of acceleration models (acceleration\+Model\+List\+\_\+) form the map of map of acceleration models (acceleration\+Models\+Per\+Body\+\_\+). \index{tudat\+::propagators\+::\+N\+Body\+State\+Derivative@{tudat\+::propagators\+::\+N\+Body\+State\+Derivative}!get\+Accelerations\+Map@{get\+Accelerations\+Map}}
\index{get\+Accelerations\+Map@{get\+Accelerations\+Map}!tudat\+::propagators\+::\+N\+Body\+State\+Derivative@{tudat\+::propagators\+::\+N\+Body\+State\+Derivative}}
\subsubsection[{\texorpdfstring{get\+Accelerations\+Map()}{getAccelerationsMap()}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename State\+Scalar\+Type  = double, typename Time\+Type  = double$>$ basic\+\_\+astrodynamics\+::\+Acceleration\+Map {\bf tudat\+::propagators\+::\+N\+Body\+State\+Derivative}$<$ State\+Scalar\+Type, Time\+Type $>$\+::get\+Accelerations\+Map (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{classtudat_1_1propagators_1_1NBodyStateDerivative_a3c8a3939cf0e2a6b2ea1c23e44196ac7}{}\label{classtudat_1_1propagators_1_1NBodyStateDerivative_a3c8a3939cf0e2a6b2ea1c23e44196ac7}


Function to retrieve the map containing the list of accelerations acting on each body. 

Function to retrieve the map containing the list of accelerations acting on each body. \begin{DoxyReturn}{Returns}
Map containing the list of accelerations acting on each body, 
\end{DoxyReturn}
\index{tudat\+::propagators\+::\+N\+Body\+State\+Derivative@{tudat\+::propagators\+::\+N\+Body\+State\+Derivative}!get\+Bodies\+To\+Be\+Integrated\+Numerically@{get\+Bodies\+To\+Be\+Integrated\+Numerically}}
\index{get\+Bodies\+To\+Be\+Integrated\+Numerically@{get\+Bodies\+To\+Be\+Integrated\+Numerically}!tudat\+::propagators\+::\+N\+Body\+State\+Derivative@{tudat\+::propagators\+::\+N\+Body\+State\+Derivative}}
\subsubsection[{\texorpdfstring{get\+Bodies\+To\+Be\+Integrated\+Numerically()}{getBodiesToBeIntegratedNumerically()}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename State\+Scalar\+Type  = double, typename Time\+Type  = double$>$ std\+::vector$<$ std\+::string $>$ {\bf tudat\+::propagators\+::\+N\+Body\+State\+Derivative}$<$ State\+Scalar\+Type, Time\+Type $>$\+::get\+Bodies\+To\+Be\+Integrated\+Numerically (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{classtudat_1_1propagators_1_1NBodyStateDerivative_a6371faac2a8c345ff0b585708e5df1f8}{}\label{classtudat_1_1propagators_1_1NBodyStateDerivative_a6371faac2a8c345ff0b585708e5df1f8}


Function to get list of names of bodies that are to be integrated numerically. 

Function to get list of names of bodies that are to be integrated numerically. \begin{DoxyReturn}{Returns}
List of names of bodies that are to be integrated numerically. 
\end{DoxyReturn}
\index{tudat\+::propagators\+::\+N\+Body\+State\+Derivative@{tudat\+::propagators\+::\+N\+Body\+State\+Derivative}!get\+Central\+Body\+Data@{get\+Central\+Body\+Data}}
\index{get\+Central\+Body\+Data@{get\+Central\+Body\+Data}!tudat\+::propagators\+::\+N\+Body\+State\+Derivative@{tudat\+::propagators\+::\+N\+Body\+State\+Derivative}}
\subsubsection[{\texorpdfstring{get\+Central\+Body\+Data()}{getCentralBodyData()}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename State\+Scalar\+Type  = double, typename Time\+Type  = double$>$ boost\+::shared\+\_\+ptr$<$ {\bf Central\+Body\+Data}$<$ State\+Scalar\+Type, Time\+Type $>$ $>$ {\bf tudat\+::propagators\+::\+N\+Body\+State\+Derivative}$<$ State\+Scalar\+Type, Time\+Type $>$\+::get\+Central\+Body\+Data (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{classtudat_1_1propagators_1_1NBodyStateDerivative_a3f9dbc0f8bff359e387bdc8a488e1495}{}\label{classtudat_1_1propagators_1_1NBodyStateDerivative_a3f9dbc0f8bff359e387bdc8a488e1495}


Function to get object providing the current integration origins. 

Function to get object responsible for providing the current integration origins from the global origins. \begin{DoxyReturn}{Returns}
Object providing the current integration origins from the global origins. 
\end{DoxyReturn}
\index{tudat\+::propagators\+::\+N\+Body\+State\+Derivative@{tudat\+::propagators\+::\+N\+Body\+State\+Derivative}!get\+Full\+Accelerations\+Map@{get\+Full\+Accelerations\+Map}}
\index{get\+Full\+Accelerations\+Map@{get\+Full\+Accelerations\+Map}!tudat\+::propagators\+::\+N\+Body\+State\+Derivative@{tudat\+::propagators\+::\+N\+Body\+State\+Derivative}}
\subsubsection[{\texorpdfstring{get\+Full\+Accelerations\+Map()}{getFullAccelerationsMap()}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename State\+Scalar\+Type  = double, typename Time\+Type  = double$>$ virtual basic\+\_\+astrodynamics\+::\+Acceleration\+Map {\bf tudat\+::propagators\+::\+N\+Body\+State\+Derivative}$<$ State\+Scalar\+Type, Time\+Type $>$\+::get\+Full\+Accelerations\+Map (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}\hypertarget{classtudat_1_1propagators_1_1NBodyStateDerivative_ace7b03eeaa9a2571af87d578d3b747c7}{}\label{classtudat_1_1propagators_1_1NBodyStateDerivative_ace7b03eeaa9a2571af87d578d3b747c7}


Function to get map containing the list of accelerations acting on each body,. 

Function to get map containing the list of accelerations acting on each body, \begin{DoxyReturn}{Returns}
A map containing the list of accelerations acting on each body, 
\end{DoxyReturn}


Reimplemented in \hyperlink{classtudat_1_1propagators_1_1NBodyEnckeStateDerivative_aa08f372eed53077155c3572d0db36e57}{tudat\+::propagators\+::\+N\+Body\+Encke\+State\+Derivative$<$ State\+Scalar\+Type, Time\+Type $>$}.

\index{tudat\+::propagators\+::\+N\+Body\+State\+Derivative@{tudat\+::propagators\+::\+N\+Body\+State\+Derivative}!get\+Propagator\+Type@{get\+Propagator\+Type}}
\index{get\+Propagator\+Type@{get\+Propagator\+Type}!tudat\+::propagators\+::\+N\+Body\+State\+Derivative@{tudat\+::propagators\+::\+N\+Body\+State\+Derivative}}
\subsubsection[{\texorpdfstring{get\+Propagator\+Type()}{getPropagatorType()}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename State\+Scalar\+Type  = double, typename Time\+Type  = double$>$ Translational\+Propagator\+Type {\bf tudat\+::propagators\+::\+N\+Body\+State\+Derivative}$<$ State\+Scalar\+Type, Time\+Type $>$\+::get\+Propagator\+Type (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{classtudat_1_1propagators_1_1NBodyStateDerivative_a6854e29873694a2ec2f25950b5315796}{}\label{classtudat_1_1propagators_1_1NBodyStateDerivative_a6854e29873694a2ec2f25950b5315796}


Function to get type of propagator that is to be used (i.\+e. Cowell, Encke, etc.) 

Function to type of propagator that is to be used (i.\+e. Cowell, Encke, etc.) \begin{DoxyReturn}{Returns}
Type of propagator that is to be used (i.\+e. Cowell, Encke, etc.) 
\end{DoxyReturn}
\index{tudat\+::propagators\+::\+N\+Body\+State\+Derivative@{tudat\+::propagators\+::\+N\+Body\+State\+Derivative}!get\+State\+Size@{get\+State\+Size}}
\index{get\+State\+Size@{get\+State\+Size}!tudat\+::propagators\+::\+N\+Body\+State\+Derivative@{tudat\+::propagators\+::\+N\+Body\+State\+Derivative}}
\subsubsection[{\texorpdfstring{get\+State\+Size()}{getStateSize()}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename State\+Scalar\+Type  = double, typename Time\+Type  = double$>$ int {\bf tudat\+::propagators\+::\+N\+Body\+State\+Derivative}$<$ State\+Scalar\+Type, Time\+Type $>$\+::get\+State\+Size (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}\hypertarget{classtudat_1_1propagators_1_1NBodyStateDerivative_a93aeb6b8f4de1817816ad19ddec65a19}{}\label{classtudat_1_1propagators_1_1NBodyStateDerivative_a93aeb6b8f4de1817816ad19ddec65a19}


Function to return the size of the state handled by the object. 

Function to return the size of the state handled by the object \begin{DoxyReturn}{Returns}
Size of the state under consideration (6 times the number if integrated bodies). 
\end{DoxyReturn}


Implements \hyperlink{classtudat_1_1propagators_1_1SingleStateTypeDerivative_a53afad2061854a2cc8c03bfce3b3cf2a}{tudat\+::propagators\+::\+Single\+State\+Type\+Derivative$<$ State\+Scalar\+Type, Time\+Type $>$}.

\index{tudat\+::propagators\+::\+N\+Body\+State\+Derivative@{tudat\+::propagators\+::\+N\+Body\+State\+Derivative}!get\+Total\+Acceleration\+For\+Body@{get\+Total\+Acceleration\+For\+Body}}
\index{get\+Total\+Acceleration\+For\+Body@{get\+Total\+Acceleration\+For\+Body}!tudat\+::propagators\+::\+N\+Body\+State\+Derivative@{tudat\+::propagators\+::\+N\+Body\+State\+Derivative}}
\subsubsection[{\texorpdfstring{get\+Total\+Acceleration\+For\+Body(const std\+::string \&body\+Name)}{getTotalAccelerationForBody(const std::string &bodyName)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename State\+Scalar\+Type  = double, typename Time\+Type  = double$>$ Eigen\+::\+Vector3d {\bf tudat\+::propagators\+::\+N\+Body\+State\+Derivative}$<$ State\+Scalar\+Type, Time\+Type $>$\+::get\+Total\+Acceleration\+For\+Body (
\begin{DoxyParamCaption}
\item[{const std\+::string \&}]{body\+Name}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{classtudat_1_1propagators_1_1NBodyStateDerivative_a2f6fa526b5bfa1e80a7c4a80fa36ea91}{}\label{classtudat_1_1propagators_1_1NBodyStateDerivative_a2f6fa526b5bfa1e80a7c4a80fa36ea91}


Function to retrieve the total acceleration acting on a given body. 

Function to retrieve the total acceleration acting on a given body. The environment and acceleration models must have been updated to the current state before calling this function. N\+O\+TE\+: This function is typically used to retrieve the acceleration for output purposes, not to compute the translational state derivative. 
\begin{DoxyParams}{Parameters}
{\em body\+Name} & Name of body for which accelerations are to be retrieved. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}
\index{tudat\+::propagators\+::\+N\+Body\+State\+Derivative@{tudat\+::propagators\+::\+N\+Body\+State\+Derivative}!sum\+State\+Derivative\+Contributions@{sum\+State\+Derivative\+Contributions}}
\index{sum\+State\+Derivative\+Contributions@{sum\+State\+Derivative\+Contributions}!tudat\+::propagators\+::\+N\+Body\+State\+Derivative@{tudat\+::propagators\+::\+N\+Body\+State\+Derivative}}
\subsubsection[{\texorpdfstring{sum\+State\+Derivative\+Contributions(const Eigen\+::\+Matrix$<$ State\+Scalar\+Type, Eigen\+::\+Dynamic, 1 $>$ \&state\+Of\+System\+To\+Be\+Integrated, Eigen\+::\+Block$<$ Eigen\+::\+Matrix$<$ State\+Scalar\+Type, Eigen\+::\+Dynamic, Eigen\+::\+Dynamic $>$ $>$ state\+Derivative)}{sumStateDerivativeContributions(const Eigen::Matrix< StateScalarType, Eigen::Dynamic, 1 > &stateOfSystemToBeIntegrated, Eigen::Block< Eigen::Matrix< StateScalarType, Eigen::Dynamic, Eigen::Dynamic > > stateDerivative)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename State\+Scalar\+Type  = double, typename Time\+Type  = double$>$ void {\bf tudat\+::propagators\+::\+N\+Body\+State\+Derivative}$<$ State\+Scalar\+Type, Time\+Type $>$\+::sum\+State\+Derivative\+Contributions (
\begin{DoxyParamCaption}
\item[{const Eigen\+::\+Matrix$<$ State\+Scalar\+Type, Eigen\+::\+Dynamic, 1 $>$ \&}]{state\+Of\+System\+To\+Be\+Integrated, }
\item[{Eigen\+::\+Block$<$ Eigen\+::\+Matrix$<$ State\+Scalar\+Type, Eigen\+::\+Dynamic, Eigen\+::\+Dynamic $>$ $>$}]{state\+Derivative}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [protected]}}\hypertarget{classtudat_1_1propagators_1_1NBodyStateDerivative_a9dc88981ebb90ecf8f7673760d321597}{}\label{classtudat_1_1propagators_1_1NBodyStateDerivative_a9dc88981ebb90ecf8f7673760d321597}


Function to get the state derivative of the system in Cartesian coordinates. 

Function to get the state derivative of the system in Cartesian coordinates. The environment and acceleration models must have been updated to the current state before calling this function. 
\begin{DoxyParams}{Parameters}
{\em state\+Of\+System\+To\+Be\+Integrated} & Current Cartesian state of the system. \\
\hline
{\em state\+Derivative} & State derivative of the system in Cartesian coordinates (returned by reference). \\
\hline
\end{DoxyParams}
\index{tudat\+::propagators\+::\+N\+Body\+State\+Derivative@{tudat\+::propagators\+::\+N\+Body\+State\+Derivative}!update\+State\+Derivative\+Model@{update\+State\+Derivative\+Model}}
\index{update\+State\+Derivative\+Model@{update\+State\+Derivative\+Model}!tudat\+::propagators\+::\+N\+Body\+State\+Derivative@{tudat\+::propagators\+::\+N\+Body\+State\+Derivative}}
\subsubsection[{\texorpdfstring{update\+State\+Derivative\+Model(const Time\+Type current\+Time)}{updateStateDerivativeModel(const TimeType currentTime)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename State\+Scalar\+Type  = double, typename Time\+Type  = double$>$ void {\bf tudat\+::propagators\+::\+N\+Body\+State\+Derivative}$<$ State\+Scalar\+Type, Time\+Type $>$\+::update\+State\+Derivative\+Model (
\begin{DoxyParamCaption}
\item[{const Time\+Type}]{current\+Time}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}\hypertarget{classtudat_1_1propagators_1_1NBodyStateDerivative_a1db2b5b538eeb857e040a8744d886e61}{}\label{classtudat_1_1propagators_1_1NBodyStateDerivative_a1db2b5b538eeb857e040a8744d886e61}


Function to update the state derivative model to the current time. 

Function to update the state derivative model (i.\+e. acceleration, torque, etc. models) to the current time. Note that this function only updates the state derivative model itself, the environment models must be updated before calling this function. 
\begin{DoxyParams}{Parameters}
{\em current\+Time} & \hyperlink{classtudat_1_1Time}{Time} at which state derivative is to be calculated \\
\hline
\end{DoxyParams}


Implements \hyperlink{classtudat_1_1propagators_1_1SingleStateTypeDerivative_a9542fa3986fabe6129f0bf5b788daeba}{tudat\+::propagators\+::\+Single\+State\+Type\+Derivative$<$ State\+Scalar\+Type, Time\+Type $>$}.



\subsection{Member Data Documentation}
\index{tudat\+::propagators\+::\+N\+Body\+State\+Derivative@{tudat\+::propagators\+::\+N\+Body\+State\+Derivative}!acceleration\+Models\+Per\+Body\+\_\+@{acceleration\+Models\+Per\+Body\+\_\+}}
\index{acceleration\+Models\+Per\+Body\+\_\+@{acceleration\+Models\+Per\+Body\+\_\+}!tudat\+::propagators\+::\+N\+Body\+State\+Derivative@{tudat\+::propagators\+::\+N\+Body\+State\+Derivative}}
\subsubsection[{\texorpdfstring{acceleration\+Models\+Per\+Body\+\_\+}{accelerationModelsPerBody_}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename State\+Scalar\+Type  = double, typename Time\+Type  = double$>$ basic\+\_\+astrodynamics\+::\+Acceleration\+Map {\bf tudat\+::propagators\+::\+N\+Body\+State\+Derivative}$<$ State\+Scalar\+Type, Time\+Type $>$\+::acceleration\+Models\+Per\+Body\+\_\+\hspace{0.3cm}{\ttfamily [protected]}}\hypertarget{classtudat_1_1propagators_1_1NBodyStateDerivative_aa9ae6d8dfda131ffca5b23c1564342af}{}\label{classtudat_1_1propagators_1_1NBodyStateDerivative_aa9ae6d8dfda131ffca5b23c1564342af}


A map containing the list of accelerations acting on each body,. 

A map containing the list of accelerations acting on each body, identifying the body being acted on and the body acted on by an acceleration. The map has as key a string denoting the name of the body the list of accelerations, provided as the value corresponding to a key, is acting on. This map-\/value is again a map with string as key, denoting the body exerting the acceleration, and as value a pointer to an acceleration model. 

The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
/home/lupi/\+Tudat/tudat\+Bundle/tudat/\+Tudat/\+Astrodynamics/\+Propagators/n\+Body\+State\+Derivative.\+h\end{DoxyCompactItemize}
